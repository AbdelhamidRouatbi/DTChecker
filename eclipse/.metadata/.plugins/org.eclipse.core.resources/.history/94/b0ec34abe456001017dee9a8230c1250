/*
 * generated by Xtext 2.37.0
 */
package org.xtext.stlrobust.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.charset.StandardCharsets
import org.xtext.stlrobust.spec.*
import java.io.File

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SpecGenerator extends AbstractGenerator {
	
	def String loadTemplate(String fileName) {
  		return Files.readString(Paths.get("resources/templates/" + fileName), StandardCharsets.UTF_8)
	}
	
	def String renderSpec(Specification spec, String template) {
  template
    .replace('${name}', spec.name)
    .replace('${scope}', spec.scope.toString)
    .replace('${pattern}', spec.pattern.toString)
}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		print("Generating python scripts...\n")
		val model = resource.contents.head as Model
		fsa.generateFile("/DEFAULT_ARTIFACT", generateSpec(model))
		print("generation successful\n")
  }
  
  def generateSpec(Model model){
  	val signals = model.signals
  	val specs = model.specifications
  	return '''
 
 import pika, rtamt, time, os, sys, requests, json
 from specs import SpecManager
 from functools import partial
 
 def main():
 
 «'   '»specManager = SpecManager()
 
 «'   '»#RabbitMQ Setup
    credentials = pika.PlainCredentials('incubator', 'incubator')
    parameters = pika.ConnectionParameters('localhost', credentials=credentials)
    connection = pika.BlockingConnection(parameters)
    channel = connection.channel()

 «FOR signal : signals»
 «'   '»channel.queue_declare(queue='«signal.queueName»', durable=True)
 «ENDFOR»
 
    #Specs Setup
 «FOR spec : specs»
«'   '»specManager.addSpec("«spec.name»", "«generateSTL(spec)»")
 «ENDFOR»
 
 «FOR signal : signals»
«'   '»specManager.addSpec("signal-«signal.name»", "always[0,0](«signal.name»>0)")
 «ENDFOR»
 
 «'   '»def evaluate(ch, method, properties, body, signal):
 «'      '»value = None
 «'      '»try:
 «'         '»decoded = body.decode('utf-8').strip()
 «'         '»try:
 «'            '»value = float(decoded)
 «'         '»except ValueError:
 «'               '»parsed = json.loads(decoded)
 «'               '»if isinstance(parsed, dict):
 «'                  '»first_value = next(iter(parsed.values()))
 «'                  '»if isinstance(first_value, bool):
 «'                     '»value = int(first_value)
 «'                  '»else:
 «'                     '»raise ValueError("Expected boolean in JSON dict")
 «'               '»else:
 «'                  '»raise ValueError("Expected dict if not a float")
 «'      '»except(json.JSONDecodeError, ValueError, TypeError) as e:
 «'         '»print("Failed to parse body:", e)
 «'      '»specManager.evaluate(signal, value, time.time()*1000)
 
 «FOR signal : signals»
«'   '»channel.basic_consume(queue='«signal.queueName»', auto_ack=True, on_message_callback=partial(evaluate, signal='«signal.name»'))
 «ENDFOR»
 «'   '»print('Monitoring started')
 «'   '»channel.start_consuming()
 	
 	
 if __name__ == '__main__':
 	try:
 		main()
 	except KeyboardInterrupt:
 		print('Interrupted')
 		try:
 			sys.exit(0)
 		except SystemExit:
 			os._exit(0)
  	'''
  }
  
  def generateSTL(Specification spec) {
  	switch spec.pattern{
  		case spec.pattern instanceof Universality: return UniversalityGenerator.generate(spec)
    	case spec.pattern instanceof Absence: return AbsenceGenerator.generate(spec)
    	case spec.pattern instanceof Existence: return ExistenceGenerator.generate(spec)
    	case spec.pattern instanceof Response: return ResponseGenerator.generate(spec)
  		/*
    	case spec.pattern instanceof MinimumDuration: return MinimumDurationGenerator.generate(spec)
    	case spec.pattern instanceof MaximumDuration: return MaximumDurationGenerator.generate(spec)
    	case spec.pattern instanceof Recurrence: return RecurrenceGenerator.generate(spec)
    	case spec.pattern instanceof Precedence: return PrecedenceGenerator.generate(spec)
    	case spec.pattern instanceof Until: return UntilGenerator.generate(spec)
    	case spec.pattern instanceof ResponseInvariance: return ResponseInvarianceGenerator.generate(spec)
    	*/
  	}
  	
  	
  }
  
  def static time(Time t){
		if (t !== null){
			switch(t){
			case t instanceof UpperTimeBound: return '''[0, «(t as UpperTimeBound).value»]'''
			case t instanceof LowerTimeBound: return '''[«(t as LowerTimeBound).value»,«(t as LowerTimeBound).value»]'''
			case t instanceof Interval: return '''[«(t as Interval).min»,«(t as Interval).max»]'''
			} 
		}
		return ''''''
	}
	
	// TODO: numbers with a 0 after comma
	def static number(Number n){
		var result = ""
		var sign = ""
		if (n.sign !== null) sign += ("-")
		result += sign
		result += n.intValue
		var Integer decimalPart = n.decimalValue
		if (decimalPart !== null) result += "." + decimalPart
		return result
	}
	
	def static expression(Expression e){
		var lefthand = (e.s1 !== null)?e.s1.name:number(e.f1)
		var operator = e.operator
		var righthand = (e.s2 !== null)?e.s2.name:number(e.f2)
		return "(" + lefthand + operator + righthand + ")"
	}
  
  
  
  
  
}
