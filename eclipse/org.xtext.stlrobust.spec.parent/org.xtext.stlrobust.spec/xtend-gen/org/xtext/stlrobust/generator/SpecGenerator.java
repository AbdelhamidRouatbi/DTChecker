/**
 * generated by Xtext 2.37.0
 */
package org.xtext.stlrobust.generator;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.stlrobust.spec.Absence;
import org.xtext.stlrobust.spec.Existence;
import org.xtext.stlrobust.spec.Expression;
import org.xtext.stlrobust.spec.Interval;
import org.xtext.stlrobust.spec.LowerTimeBound;
import org.xtext.stlrobust.spec.Model;
import org.xtext.stlrobust.spec.Pattern;
import org.xtext.stlrobust.spec.Response;
import org.xtext.stlrobust.spec.Signal;
import org.xtext.stlrobust.spec.Specification;
import org.xtext.stlrobust.spec.Time;
import org.xtext.stlrobust.spec.Universality;
import org.xtext.stlrobust.spec.UpperTimeBound;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SpecGenerator extends AbstractGenerator {
  public String loadTemplate(final String fileName) {
    try {
      return Files.readString(Paths.get(("resources/templates/" + fileName)), StandardCharsets.UTF_8);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  public String renderSpec(final Specification spec, final String template) {
    return template.replace("${name}", spec.getName()).replace("${scope}", spec.getScope().toString()).replace("${pattern}", spec.getPattern().toString());
  }

  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    InputOutput.<String>print("Generating python scripts...\n");
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    final Model model = ((Model) _head);
    fsa.generateFile("/DEFAULT_ARTIFACT", this.generateSpec(model));
    InputOutput.<String>print("generation successful\n");
  }

  public String generateSpec(final Model model) {
    final EList<Signal> signals = model.getSignals();
    final EList<Specification> specs = model.getSpecifications();
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("import pika, rtamt, time, os, sys, requests, json");
    _builder.newLine();
    _builder.append("from specs import SpecManager");
    _builder.newLine();
    _builder.append("from functools import partial");
    _builder.newLine();
    _builder.newLine();
    _builder.append("def main():");
    _builder.newLine();
    _builder.newLine();
    _builder.append("   ");
    _builder.append("specManager = SpecManager()");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("   ");
    _builder.append("#RabbitMQ Setup");
    _builder.newLineIfNotEmpty();
    _builder.append("   ");
    _builder.append("credentials = pika.PlainCredentials(\'incubator\', \'incubator\')");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("parameters = pika.ConnectionParameters(\'localhost\', credentials=credentials)");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("connection = pika.BlockingConnection(parameters)");
    _builder.newLine();
    _builder.append("   ");
    _builder.append("channel = connection.channel()");
    _builder.newLine();
    _builder.newLine();
    {
      for(final Signal signal : signals) {
        _builder.append("channel.queue_declare(queue=\'");
        String _queueName = signal.getQueueName();
        _builder.append(_queueName);
        _builder.append("\', durable=True)");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("   ");
    _builder.append("#Specs Setup");
    _builder.newLine();
    {
      for(final Specification spec : specs) {
        _builder.append("specManager.addSpec(\"");
        String _name = spec.getName();
        _builder.append(_name);
        _builder.append("\", \"");
        Object _generateSTL = this.generateSTL(spec);
        _builder.append(_generateSTL);
        _builder.append("\")");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    {
      for(final Signal signal_1 : signals) {
        _builder.append("   ");
        _builder.append("specManager.addSpec(\"signal-");
        String _name_1 = signal_1.getName();
        _builder.append(_name_1);
        _builder.append("\", \"always[0,0](");
        String _name_2 = signal_1.getName();
        _builder.append(_name_2);
        _builder.append(">0)\")");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    _builder.append("   ");
    _builder.append("def evaluate(ch, method, properties, body, signal):");
    _builder.newLineIfNotEmpty();
    _builder.append("      ");
    _builder.append("value = None");
    _builder.newLineIfNotEmpty();
    _builder.append("      ");
    _builder.append("try:");
    _builder.newLineIfNotEmpty();
    _builder.append("         ");
    _builder.append("decoded = body.decode(\'utf-8\').strip()");
    _builder.newLineIfNotEmpty();
    _builder.append("         ");
    _builder.append("try:");
    _builder.newLineIfNotEmpty();
    _builder.append("            ");
    _builder.append("value = float(decoded)");
    _builder.newLineIfNotEmpty();
    _builder.append("         ");
    _builder.append("except ValueError:");
    _builder.newLineIfNotEmpty();
    _builder.append("               ");
    _builder.append("parsed = json.loads(decoded)");
    _builder.newLineIfNotEmpty();
    _builder.append("               ");
    _builder.append("if isinstance(parsed, dict):");
    _builder.newLineIfNotEmpty();
    _builder.append("                  ");
    _builder.append("first_value = next(iter(parsed.values()))");
    _builder.newLineIfNotEmpty();
    _builder.append("                  ");
    _builder.append("if isinstance(first_value, bool):");
    _builder.newLineIfNotEmpty();
    _builder.append("                     ");
    _builder.append("value = int(first_value)");
    _builder.newLineIfNotEmpty();
    _builder.append("                  ");
    _builder.append("else:");
    _builder.newLineIfNotEmpty();
    _builder.append("                     ");
    _builder.append("raise ValueError(\"Expected boolean in JSON dict\")");
    _builder.newLineIfNotEmpty();
    _builder.append("               ");
    _builder.append("else:");
    _builder.newLineIfNotEmpty();
    _builder.append("                  ");
    _builder.append("raise ValueError(\"Expected dict if not a float\")");
    _builder.newLineIfNotEmpty();
    _builder.append("      ");
    _builder.append("except(json.JSONDecodeError, ValueError, TypeError) as e:");
    _builder.newLineIfNotEmpty();
    _builder.append("         ");
    _builder.append("print(\"Failed to parse body:\", e)");
    _builder.newLineIfNotEmpty();
    _builder.append("      ");
    _builder.append("specManager.evaluate(signal, value, time.time()*1000)");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    {
      for(final Signal signal_2 : signals) {
        _builder.append("   ");
        _builder.append("channel.basic_consume(queue=\'");
        String _queueName_1 = signal_2.getQueueName();
        _builder.append(_queueName_1);
        _builder.append("\', auto_ack=True, on_message_callback=partial(evaluate, signal=\'");
        String _name_3 = signal_2.getName();
        _builder.append(_name_3);
        _builder.append("\'))");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("   ");
    _builder.append("print(\'Monitoring started\')");
    _builder.newLineIfNotEmpty();
    _builder.append("   ");
    _builder.append("channel.start_consuming()");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("if __name__ == \'__main__\':");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("try:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("main()");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("except KeyboardInterrupt:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("print(\'Interrupted\')");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("try:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("sys.exit(0)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("except SystemExit:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("os._exit(0)");
    _builder.newLine();
    return _builder.toString();
  }

  public Object generateSTL(final Specification spec) {
    Pattern _pattern = spec.getPattern();
    boolean _matched = false;
    Pattern _pattern_1 = spec.getPattern();
    if ((_pattern_1 instanceof Universality)) {
      _matched=true;
      return UniversalityGenerator.generate(spec);
    }
    if (!_matched) {
      Pattern _pattern_2 = spec.getPattern();
      if ((_pattern_2 instanceof Absence)) {
        _matched=true;
        return AbsenceGenerator.generate(spec);
      }
    }
    if (!_matched) {
      Pattern _pattern_3 = spec.getPattern();
      if ((_pattern_3 instanceof Existence)) {
        _matched=true;
        return ExistenceGenerator.generate(spec);
      }
    }
    if (!_matched) {
      Pattern _pattern_4 = spec.getPattern();
      if ((_pattern_4 instanceof Response)) {
        _matched=true;
        return ResponseGenerator.generate(spec);
      }
    }
    return null;
  }

  public static String time(final Time t) {
    if ((t != null)) {
      int multiplier = 1;
      String _unit = t.getUnit();
      if (_unit != null) {
        switch (_unit) {
          case "ms":
            multiplier = 1;
            break;
          case "s":
            multiplier = 1000;
            break;
          case "min":
            multiplier = (1000 * 60);
            break;
        }
      }
      boolean _matched = false;
      if ((t instanceof UpperTimeBound)) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("[0, ");
        int _value = ((UpperTimeBound) t).getValue();
        int _multiply = (_value * multiplier);
        _builder.append(_multiply);
        _builder.append("]");
        return _builder.toString();
      }
      if (!_matched) {
        if ((t instanceof LowerTimeBound)) {
          _matched=true;
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("[");
          int _value_1 = ((LowerTimeBound) t).getValue();
          int _multiply_1 = (_value_1 * multiplier);
          _builder_1.append(_multiply_1);
          _builder_1.append(",");
          int _value_2 = ((LowerTimeBound) t).getValue();
          int _multiply_2 = (_value_2 * multiplier);
          _builder_1.append(_multiply_2);
          _builder_1.append("]");
          return _builder_1.toString();
        }
      }
      if (!_matched) {
        if ((t instanceof Interval)) {
          _matched=true;
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("[");
          int _min = ((Interval) t).getMin();
          int _multiply_3 = (_min * multiplier);
          _builder_2.append(_multiply_3);
          _builder_2.append(",");
          int _max = ((Interval) t).getMax();
          int _multiply_4 = (_max * multiplier);
          _builder_2.append(_multiply_4);
          _builder_2.append("]");
          return _builder_2.toString();
        }
      }
    }
    StringConcatenation _builder_3 = new StringConcatenation();
    return _builder_3.toString();
  }

  public static String number(final org.xtext.stlrobust.spec.Number n) {
    String result = "";
    String sign = "";
    String _sign = n.getSign();
    boolean _tripleNotEquals = (_sign != null);
    if (_tripleNotEquals) {
      String _sign_1 = sign;
      sign = (_sign_1 + "-");
    }
    String _result = result;
    result = (_result + sign);
    String _result_1 = result;
    int _intValue = n.getIntValue();
    result = (_result_1 + Integer.valueOf(_intValue));
    Integer decimalPart = Integer.valueOf(n.getDecimalValue());
    if ((decimalPart != null)) {
      String _result_2 = result;
      result = (_result_2 + ("." + decimalPart));
    }
    return result;
  }

  public static String expression(final Expression e) {
    String _xifexpression = null;
    Signal _s1 = e.getS1();
    boolean _tripleNotEquals = (_s1 != null);
    if (_tripleNotEquals) {
      _xifexpression = e.getS1().getName();
    } else {
      _xifexpression = SpecGenerator.number(e.getF1());
    }
    String lefthand = _xifexpression;
    String _xifexpression_1 = null;
    String _operator = e.getOperator();
    boolean _equals = Objects.equals(_operator, "=");
    if (_equals) {
      _xifexpression_1 = "==";
    } else {
      _xifexpression_1 = e.getOperator();
    }
    final String operator = _xifexpression_1;
    String _xifexpression_2 = null;
    Signal _s2 = e.getS2();
    boolean _tripleNotEquals_1 = (_s2 != null);
    if (_tripleNotEquals_1) {
      _xifexpression_2 = e.getS2().getName();
    } else {
      _xifexpression_2 = SpecGenerator.number(e.getF2());
    }
    String righthand = _xifexpression_2;
    return (((("(" + lefthand) + operator) + righthand) + ")");
  }
}
