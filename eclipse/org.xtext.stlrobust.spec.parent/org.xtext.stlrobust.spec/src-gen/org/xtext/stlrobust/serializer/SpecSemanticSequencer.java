/*
 * generated by Xtext 2.37.0
 */
package org.xtext.stlrobust.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.stlrobust.services.SpecGrammarAccess;
import org.xtext.stlrobust.spec.Absence;
import org.xtext.stlrobust.spec.AfterScope;
import org.xtext.stlrobust.spec.AfterUntilScope;
import org.xtext.stlrobust.spec.BeforeScope;
import org.xtext.stlrobust.spec.BetweenScope;
import org.xtext.stlrobust.spec.Existence;
import org.xtext.stlrobust.spec.Expression;
import org.xtext.stlrobust.spec.GlobalScope;
import org.xtext.stlrobust.spec.Interval;
import org.xtext.stlrobust.spec.LowerTimeBound;
import org.xtext.stlrobust.spec.Model;
import org.xtext.stlrobust.spec.Response;
import org.xtext.stlrobust.spec.Signal;
import org.xtext.stlrobust.spec.SpecPackage;
import org.xtext.stlrobust.spec.Specification;
import org.xtext.stlrobust.spec.Universality;
import org.xtext.stlrobust.spec.UpperTimeBound;

@SuppressWarnings("all")
public class SpecSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpecGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpecPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpecPackage.ABSENCE:
				sequence_Absence(context, (Absence) semanticObject); 
				return; 
			case SpecPackage.AFTER_SCOPE:
				sequence_Scope(context, (AfterScope) semanticObject); 
				return; 
			case SpecPackage.AFTER_UNTIL_SCOPE:
				sequence_Scope(context, (AfterUntilScope) semanticObject); 
				return; 
			case SpecPackage.BEFORE_SCOPE:
				sequence_Scope(context, (BeforeScope) semanticObject); 
				return; 
			case SpecPackage.BETWEEN_SCOPE:
				sequence_Scope(context, (BetweenScope) semanticObject); 
				return; 
			case SpecPackage.EXISTENCE:
				sequence_Existence(context, (Existence) semanticObject); 
				return; 
			case SpecPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case SpecPackage.GLOBAL_SCOPE:
				sequence_Scope(context, (GlobalScope) semanticObject); 
				return; 
			case SpecPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case SpecPackage.LOWER_TIME_BOUND:
				sequence_LowerTimeBound(context, (LowerTimeBound) semanticObject); 
				return; 
			case SpecPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SpecPackage.NUMBER:
				sequence_Number(context, (org.xtext.stlrobust.spec.Number) semanticObject); 
				return; 
			case SpecPackage.RESPONSE:
				sequence_Response(context, (Response) semanticObject); 
				return; 
			case SpecPackage.SIGNAL:
				sequence_Signal(context, (Signal) semanticObject); 
				return; 
			case SpecPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case SpecPackage.UNIVERSALITY:
				sequence_Universality(context, (Universality) semanticObject); 
				return; 
			case SpecPackage.UPPER_TIME_BOUND:
				sequence_UpperTimeBound(context, (UpperTimeBound) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pattern returns Absence
	 *     Absence returns Absence
	 *
	 * Constraint:
	 *     p=Expression
	 * </pre>
	 */
	protected void sequence_Absence(ISerializationContext context, Absence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.PATTERN__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsenceAccess().getPExpressionParserRuleCall_1_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pattern returns Existence
	 *     Existence returns Existence
	 *
	 * Constraint:
	 *     (p=Expression time=Time)
	 * </pre>
	 */
	protected void sequence_Existence(ISerializationContext context, Existence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.PATTERN__P));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.EXISTENCE__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.EXISTENCE__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistenceAccess().getPExpressionParserRuleCall_1_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getExistenceAccess().getTimeTimeParserRuleCall_3_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     ((s1=[Signal|ID] | f1=Number) (operator='&gt;' | operator='&gt;=' | operator='=' | operator='&lt;' | operator='&lt;=') (s2=[Signal|ID] | f2=Number))
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Time returns Interval
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (min=INT max=INT unit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.INTERVAL__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.INTERVAL__MIN));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.INTERVAL__MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.INTERVAL__MAX));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.TIME__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.TIME__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getMinINTTerminalRuleCall_1_0(), semanticObject.getMin());
		feeder.accept(grammarAccess.getIntervalAccess().getMaxINTTerminalRuleCall_3_0(), semanticObject.getMax());
		feeder.accept(grammarAccess.getIntervalAccess().getUnitTimeUnitParserRuleCall_4_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Time returns LowerTimeBound
	 *     LowerTimeBound returns LowerTimeBound
	 *
	 * Constraint:
	 *     (value=INT unit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_LowerTimeBound(ISerializationContext context, LowerTimeBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.LOWER_TIME_BOUND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.LOWER_TIME_BOUND__VALUE));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.TIME__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.TIME__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerTimeBoundAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getLowerTimeBoundAccess().getUnitTimeUnitParserRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((Signals+=Signal+ Specifications+=Specification+) | Specifications+=Specification+)?
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (sign='-'? intValue=INT decimalValue=INT?)
	 * </pre>
	 */
	protected void sequence_Number(ISerializationContext context, org.xtext.stlrobust.spec.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pattern returns Response
	 *     Response returns Response
	 *
	 * Constraint:
	 *     (p=Expression s=Expression time=Time)
	 * </pre>
	 */
	protected void sequence_Response(ISerializationContext context, Response semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.PATTERN__P));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.RESPONSE__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.RESPONSE__S));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.RESPONSE__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.RESPONSE__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResponseAccess().getPExpressionParserRuleCall_1_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getResponseAccess().getSExpressionParserRuleCall_3_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getResponseAccess().getTimeTimeParserRuleCall_5_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scope returns AfterScope
	 *
	 * Constraint:
	 *     q=Expression
	 * </pre>
	 */
	protected void sequence_Scope(ISerializationContext context, AfterScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.AFTER_SCOPE__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.AFTER_SCOPE__Q));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getQExpressionParserRuleCall_2_2_0(), semanticObject.getQ());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scope returns AfterUntilScope
	 *
	 * Constraint:
	 *     (q=Expression r=Expression)
	 * </pre>
	 */
	protected void sequence_Scope(ISerializationContext context, AfterUntilScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.AFTER_UNTIL_SCOPE__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.AFTER_UNTIL_SCOPE__Q));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.AFTER_UNTIL_SCOPE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.AFTER_UNTIL_SCOPE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getQExpressionParserRuleCall_4_2_0(), semanticObject.getQ());
		feeder.accept(grammarAccess.getScopeAccess().getRExpressionParserRuleCall_4_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scope returns BeforeScope
	 *
	 * Constraint:
	 *     r=Expression
	 * </pre>
	 */
	protected void sequence_Scope(ISerializationContext context, BeforeScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.BEFORE_SCOPE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.BEFORE_SCOPE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getRExpressionParserRuleCall_1_2_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scope returns BetweenScope
	 *
	 * Constraint:
	 *     (q=Expression r=Expression)
	 * </pre>
	 */
	protected void sequence_Scope(ISerializationContext context, BetweenScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.BETWEEN_SCOPE__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.BETWEEN_SCOPE__Q));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.BETWEEN_SCOPE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.BETWEEN_SCOPE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getQExpressionParserRuleCall_3_2_0(), semanticObject.getQ());
		feeder.accept(grammarAccess.getScopeAccess().getRExpressionParserRuleCall_3_4_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scope returns GlobalScope
	 *
	 * Constraint:
	 *     {GlobalScope}
	 * </pre>
	 */
	protected void sequence_Scope(ISerializationContext context, GlobalScope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Signal returns Signal
	 *
	 * Constraint:
	 *     (name=ID queueName=STRING)
	 * </pre>
	 */
	protected void sequence_Signal(ISerializationContext context, Signal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.SIGNAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.SIGNAL__NAME));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.SIGNAL__QUEUE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.SIGNAL__QUEUE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSignalAccess().getQueueNameSTRINGTerminalRuleCall_3_0(), semanticObject.getQueueName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Specification returns Specification
	 *
	 * Constraint:
	 *     (name=ID scope=Scope pattern=Pattern)
	 * </pre>
	 */
	protected void sequence_Specification(ISerializationContext context, Specification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.SPECIFICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.SPECIFICATION__NAME));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.SPECIFICATION__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.SPECIFICATION__SCOPE));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.SPECIFICATION__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.SPECIFICATION__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpecificationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpecificationAccess().getScopeScopeParserRuleCall_4_0(), semanticObject.getScope());
		feeder.accept(grammarAccess.getSpecificationAccess().getPatternPatternParserRuleCall_6_0(), semanticObject.getPattern());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Pattern returns Universality
	 *     Universality returns Universality
	 *
	 * Constraint:
	 *     p=Expression
	 * </pre>
	 */
	protected void sequence_Universality(ISerializationContext context, Universality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.PATTERN__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniversalityAccess().getPExpressionParserRuleCall_1_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Time returns UpperTimeBound
	 *     UpperTimeBound returns UpperTimeBound
	 *
	 * Constraint:
	 *     (value=INT unit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_UpperTimeBound(ISerializationContext context, UpperTimeBound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.UPPER_TIME_BOUND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.UPPER_TIME_BOUND__VALUE));
			if (transientValues.isValueTransient(semanticObject, SpecPackage.Literals.TIME__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpecPackage.Literals.TIME__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperTimeBoundAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getUpperTimeBoundAccess().getUnitTimeUnitParserRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
}
